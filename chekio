#通过checkio来的灵感，根据世界思维名题660道一书，改编一些有趣的题目用代码来实现
#找整数最小公倍数
def checkio(data):
    lenth = len(data)
    i = 1
    while True:
        bol = False
        for j in data:
            bol += bool(i%j==0)
        if bol == lenth:
            print(i)
            break
        i+=1
                
data = (1,2,3,4,5,6,7,8,9)
checkio(data)
>>>2520

-------------------------------------------------------------------------------------------------------
#checkio_ Escher_ Compass,Map,Spyglass
#解一
def navigation(seaside):
    H, W = len(seaside), len(seaside[0])
    pos_map = {seaside[h][w]: (h, w) for h in range(H) for w in range(W) if seaside[h][w] != 0}
    yh, yw = pos_map["Y"]; del pos_map["Y"]
    function = lambda pos: max(abs(yh - pos[0]), abs(yw - pos[1]))
    return sum(function(pos_value) for pos_value in pos_map.values())

navigation([['Y',0,0,0,'C'],
            [ 0, 0,0,0, 0 ],
            [ 0, 0,0,0, 0 ],
            ['M',0,0,0,'S']])
#line 23,26 中的对寄生函数的用法值得学习，还是用的不流畅
#解二
from numpy import array, abs, argwhere
def navigation(seaside):
    a = array(seaside)
    return int(sum(map(max, abs(argwhere(a == 'Y') - argwhere(a != '0')))))
#这可太帅了吧，对于map也是用的不熟练，迭代方面的直觉欠缺
#这里用的是一个数组array的减法

-------------------------------------------------------------------------------------------------------
#一种不知道应该怎么命名的思维方法
#例：要求列出a的每一列的元素
a = ['##000',
     '00##0',
     '#00##'] 
#我一开始的思维,用for循环，改变i,j位置即可
for j in range(len(a[0])):
        column = [a[i][j] for i in range(len(a))]
>>>['0','0','#']        #但是很明显，column一直在迭代，最终只能返回最后一列元素
#正解：
#先将上面放回一列元素的办法定义为一个函数，然后引用这个函数返回所有列的元素，巧妙避免了因为无法重复命名导致的迭代
def col(data,i):
    return [data[i][j] for j in range(len(a[0]))]
 colunm = [col(a,i) for i in range(a)]
 >>>[['#','0','#'],
     ['#','0','0'],
     ['0','#','0'],
     ['0','#','#'],
     ['0','0','#']]
     
-----------------------------------------------------------------------------------------------------------
#Checkio_Escher_Solve wild Dogs

from itertools import combinations
from collections import Counter
from math import *

def wild_dogs(coords):
    def coll(a,b,c):
        return (b[0]-a[0])*(c[1]-a[1]) == (b[1]-a[1])*(c[0]-a[0])
    def dist0(a,b):
        return abs((b[0]-a[0])*a[1] - a[0]*(b[1]-a[1])) / sqrt((b[0]-a[0])**2 + (b[1]-a[1])**2)

    D = Counter((tuple(a),tuple(b)) for a,b,c in combinations(coords,3) if coll(a,b,c))
    if D:
        M = max(D.values())
        return round(min(dist0(a,b) for a,b in D if D[a,b]==M),2)
    else:
        return round(min(dist0(a,b) for a,b in combinations(coords,2)),2)

